var：在ES5及之前的版本中使用的关键字，用于声明变量。它具有函数作用域，意味着变量的作用域是在声明它的函数内部，或者如果没有函数包裹，则是全局作用域。var声明的变量可以被重新赋值，并且变量在声明之前可以被访问（变量提升）。

let：在ES6中引入的关键字，也用于声明变量。它具有块级作用域，意味着变量的作用域是在声明它的块（例如，if语句、循环或花括号内）内部。与var不同，let声明的变量不会被提升，而且在同一作用域内不能重复声明同一个变量。let声明的变量可以被重新赋值。

const：也是在ES6中引入的关键字，用于声明常量。与let类似，const具有块级作用域和不会被提升的特点。不同之处在于，const声明的变量必须进行初始化，并且不能被重新赋值。这意味着一旦使用const声明一个变量并赋予初始值，就不能再改变它的值

对象（引用类型）不能直接存入栈


# 堆  --无穷大

# 拷贝
通常只针对引用类型   原始类型只有深拷贝



# 浅拷贝
基于原对象拷贝得到一个新的对象，原对象中内容的修改会影响新对象

- 常见的浅拷贝方法：
1. Object.create(x)
2. Object.assign({},a)
3. [].concat(x)
4. 数组解构
5. arr.slice(0)
6. arr.toReverser().reverse()

  -实现原理：
    1. 借助for in遍历 原对象，将原对象的属性值增加在新对象中
    2. 因为 for in 会遍历到对象隐式具有的属性，通常要使用obj.hasOwnProperty(key)来判断拷贝的属性是不是对象显示具有的


# 深拷贝
基于原对象拷贝得到一个新的对象，原对象中内容的修改不会影响新对象

- JSON.parse(JSON.stringify(obj))
1. 不能识别BigInt类型
2. 不能拷贝 undefined Symbol function 类型的值
3. 不能处理循环引用

- structuredClone():


- 实现原理
  1. 借助for in遍历 原对象，将原对象的属性值增加在新对象中
  2. 因为 for in 会遍历到对象隐式具有的属性，通常要使用obj.hasOwnProperty(key)来判断拷贝的属性是不是对象显示具有的
  3. 如果遍历到的属性值是原始值类型，直接往新对象中赋值，如果是引用类型，递归创建新的子对象

