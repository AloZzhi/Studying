# 一、聊聊js中的类型
js中的类型分为两种：
- 原始类型：number boolean  null undefined string symbol bigInt
- 引用类型 object function array Date Map Set RegExp(正则)

原始类型是存储在栈内存中的，而引用类型是存储在堆内存中的。堆是完全二叉树
一些常考的问题
1、map和set的区别
set是一种特殊的数组，里面的值都是唯一的，一般用于实现数组去重，但是只能去重原始类型，而map可以去重引用类型。map是一种键值对的集合，与普通对象不同，普通对象只能使用字符串为键，但是map类型的键和值可以是任意类型。我们可以使用map.set()方法来添加键值对，map.get()方法来获取键值对的值。
2、正则:也是一种特殊的结构，正则结构。可以用来匹配字符串中的某些字符。
let reg = new RegExp(/\d+/g)
3、原始类型有没有自己的属性和方法？
NO，原始类型没有自己的属性和方法。
因为原始类型是存储在栈内存中的，而栈内存是一个后进先出的结构，所以原始类型是无法存储自己的属性和方法的。
5、解释一下1.toString()为什么可以执行？为什么不报错？
访问对象中不存在的属性返回undefinded,let a=1 实际上做了new Number(1)这个操作。官方在Number身上挂有一个toString()方法，所以可以执行。（实际上，所有的对象的隐式原型上都有tostring方法）
6、0.1+0.2 为什么不等于0.3？
0.1和0.2在计算机中都是以二进制的形式存储的，但是0.1和0.2的二进制表示是无限的，所以在计算机中无法精确表示0.1和0.2，所以会出现精度丢失的问题。超过js的最大安全值2**53也会导致这个问题。
7、如何解决精度丢失的问题
转换为字符串，用0将长度补齐

# 二、你知道几种判断类型的方法 / 3+2种方法
- # typeof 与 instanceof 的区别
typeof 可以用来判断原始类型除了null，但是无法准确的判断引用类型,因为会把引用类型全都判定为object。但是typeof唯独能准确的判断出function类型。
instanceof 可以用来判断引用类型，但是无法判断原始类型。
typeof是通过将值转换为二进制来判断的，instanceof 是通过原型链来判断的。
instanceof Object 会先判断a的__proto__是否等于b的prototype，如果等于则返回true，否则返回false。
NULL在二进制中被转换为了64个0，所以typeof null 会返回object。
总结：typeof可以用来判断变量的基本类型，instanceof 用来确定对象是否是指定类或其子类的实例。

- # Object.prototype.toString.call()
`Object.prototype.toString.call()` 调用对象的默认 `toString` 方法，返回 `[object Type]` 形式的字符串，准确反映对象类型，不受自定义 `toString` 方法影响，适用于所有数据类型的精确类型判断。
1. 对象身上的toString() 返回'[object object]'格式的字符串  =======> [object xxx判断出来的类型]
2. 数组身上的toString() 返回数组中每个元素用','拼接而成的字符串
3. 其他类型的toString() 返回字符串字面量

- constructor 属性：
每个对象都有一个 constructor 属性指向创建该对象的构造函数。可以通过检查这个属性来确定对象的类型，但要注意修改原型链可能会影响此属性的准确性。
(new String("abc")).constructor === String 返回 true。

- Array.isArray() 方法：
特别用于判断一个对象是否为数组。
解决了使用 typeof 或 instanceof 判断数组类型时的一些问题。
示例：Array.isArray([1, 2, 3]) 返回 true。

# 三、类型转换
## 显示转换
使用类型转换方法，将一个类型转换为另一个类型。
- Number() 方法：将值转换为数字。
- Boolean() 方法：将值转换为布尔值。
- String() 方法：将值转换为字符串。
- toString() 方法：将对象转换为字符串。
- parseInt() 方法：将字符串转换为整数。
- parseFloat() 方法：将字符串转换为浮点数。
- Object() 方法：将值转换为对象。
- Array() 方法：将值转换为数组。

## 隐式转换
算术运算(+、-、*、/、%)
比较运算(==、!=、>、<)、if、while需要布尔值地方会将非布尔值的参数自动转为布尔值
自动转换为布尔值: if、while
自动转换为字符串: x + ''拼接
自动转换为数字: 运算

- 将一个对象转换为数字会经过哪些步骤？ || ToPrimitive()的执行过程
1. ToNumber({})   任何类型要转成数字，js都会先调用ToNumber()方法。但是ToNumber()只能处理原始类型。
2. 当ToNumber({})遇到引用类型时，会内部执行调用 ToPrimitive({})
3. 调用ToPrimitive({})时，会先调用{}.valueOf()方法，如果返回的是原始类型，则直接返回；
    如果返回的是引用类型，则会调用{}.toString()方法，如果返回的是原始类型，则直接返回；
    如果返回的是引用类型，则会抛出错误。

- 问：判断 [] == 1
往数字转
[].valueOf() 返回的是一个空数组，所以会调用[]的toString()方法，返回''。'' 转换为数字是0，所以返回false
- 问：判断 [] == ![]
答案：最后返回的时 true
往数字转
在 JavaScript 中，任何引用类型的值转换为布尔值时都会被视为 true。[] == ![] 等价于 [] == false，转数字为0 == false，所以返回true。
- 问：== 和 === 的区别
 == 会进行隐式类型转换，=== 不会进行隐式类型转换用于判断值和类型是否全等。

# 四、this

- 为什么要有this?
因为在JS中没有访问自己的方法,this让对象中的函数有能力访问自己对象的属性。this可以显著提升代码质量,减少上下文参数传递

1. ## 默认绑定
- 函数被独立调用,this指向window(全局作用域)。
当一个函数独立调用不带任何修饰符的时候,此时触发默认绑定;默认绑定的this指向window和函数声明在哪,在哪调用无关。
2. ## 隐式绑定
- 函数被某个对象调用,this指向这个对象。
只要是隐式绑定（即函数作为对象的属性被调用时）,this一定指向调用该函数的对象。
隐式丢失：当一个函数被多个函数链式调用时,函数的this指向最近调用他的对象。
箭头函数没有this,但是他会在其被定义的作用域中查找this。
如果箭头函数是在一个普通函数内部定义的，那么箭头函数内的this将与外层普通函数的this保持一致。
如果箭头函数是在全局作用域中定义的，那么它的this将指向全局对象（在浏览器中是window对象，在Node.js环境中则是global对象）。
3. ## 显示绑定 call apply bind
foo.call(obj) => 将foo函数的this指向obj 
foo.apply(obj) => 将foo函数的this指向obj
const bar = foo.bind(obj)   bar() => 将foo函数的this指向obj

- call 和 apply 的区别：
call 和 apply 都是用来改变函数的 this 指向的，但是它们的参数传递方式不同。
call 可以接收多个参数，第一个参数是 this 的指向，后面的参数是函数的参数。foo.call(obj, arg1, arg2, arg3)
apply 只能接收两个参数，第一个参数是 this 的指向，第二个参数是一个数组，数组中的元素是函数的参数。foo.apply(obj, [arg1, arg2, arg3])
- bind 可以在两处接受参数：
const bar = foo.bind(obj, arg1, arg2, arg3) 
或者 bar(arg1, arg2, arg3)   两者同时接受参数时，bind接收的参数优先。

- 问：call、apply、bind 的区别：
   call、bind 接受参数是零散的，apply 接受参数是数组。bind返回的是一个函数，这个新的函数也可以接受参数，两者同时接受参数时，bind接收的参数优先。1.当新的函数被new调用时，返回的是调用bind的那个函数的实例对象。

- 问：手写call、apply、bind的实现原理

4. ## new 绑定
- 函数被new调用,this指向new出来的实例对象。
当一个函数被new调用时,此时触发new绑定;new绑定的this指向new出来的实例对象。
## new 的实现过程：
1. 创建一个新对象
2. 新对象的__proto__ 指向旧对象的prototype
3. 构造函数内部的this指向新对象
4. 执行构造函数内部代码
5. 当构造函数中有返回值且返回值的类型是引用类型时，new会返回构造函数的执行结果；否则直接返回新对象。
虽然在二进制中null会判断为object引用类型，但不妨碍new返回构造函数的执行结果。


# 五、闭包
(一个函数被执行完时，这个函数会出栈被销毁，但是因为存在闭包这个机制，所以函数执行完后，函数内部的变量不会被销毁，而是被保存到内存中，等待下一次调用。)

根据词法作用域的规则，内部函数总是可以访问其外部函数中的变量。
一个函数被执行完时，这个函数会出栈，它的执行上下文要被销毁，防止爆栈。

当函数A内部声明了一个函数B，函数B被拿到A的外部调用，为了满足以上两个规则，
函数A的执行上下文被销毁后会遗留下来一个对象空间，存放函数B相关的所有变量，这个空间就是闭包。

闭包的作用：
1. 可以保护函数内的变量安全 ，实现封装，防止变量被外界访问。

- 问：请你聊聊作用域
全局作用域、函数作用域、块级作用域、作用域链、词法作用域


# 六、拷贝
- 浅拷贝
concat slice 扩展运算符 Object.assign() object.create() 

- 深拷贝
手搓三种


# 七、原型
1. 显示原型 prototype
2. 隐式原型 __proto__

构造函数的显示原型 = 对象的隐式原型

- 原型的作用：让所有的实例对象都有一个共有的属性和方法
- 原型链： 因为对象都有自己的隐式原型，V8在查找属性和方法时会先去对象的显示属性中查找，找不到再去对象的隐式原型中查找，还找不到就会顺着隐式原型往上查找，直到查找到null为止。这种查找的关系链条就叫原型链。
- 所有对象都有原型吗？
NO, object.create()会创建一个新的对象，但是object.create(null)会创建出一个空集。

new 的实现：
1. 创建一个新对象
2. 新对象的__proto__ 指向旧对象的prototype
3. 构造函数内部的this指向新对象
4. 执行构造函数内部代码
5. 当构造函数中有返回值且返回值的类型是引用类型时，new会返回构造函数的执行结果；否则直接返回新对象。
虽然在二进制中null会判断为object引用类型，但不妨碍new返回构造函数的执行结果。

# 八、var let const的区别

1. var 没有块级作用域 let,const+{}会生成块级作用域。
2. var 会声明提升 ，let const 不会有声明提升。
3. var 可以重复声明 ， let 和const 不会。
4. const 声明的变量不能重新赋值，let和var可以。
5. var声明的变量会挂在在window上。
6. const，let 可能会导致暂时性死区：当let或const声明的变量形成了块级作用域时，使用let或const命令声明变量之前，该变量都是不可用的状态。在这段时间内，如果尝试访问该变量，将会抛出ReferenceError错误。这个区域就被称为“暂时性死区”。

# 九、继承
- 让子类能够访问到父类的属性和方法

1. 通过原型链的继承:子类无法给父类传参
2. 借用构造函数继承：无法继承原型链上的方法
3. 组合继承：父类构造函数被继承了两次，如果父类太大可能会造成性能消耗
4. 原型式继承：直接将你需要继承的对象当作参数传入object.create()中
*5. 寄生组合继承：常考手搓

*6. class 继承: 通过extends+super 实现

# 十、proxy
es6 新增的一个特性，用来代理对象，代理对象上的读取、设置、函数调用等13种行为。vue3主要依靠proxy实现响应式。

# Reflect
proxy的改进版本

# 十一、map、filter、reduce、forEach
map: 遍历数组，将原数组的每一项都执行一次回调函数，返回一个新数组。
filter: 遍历数组，将数组中满足条件的哪些项保留到新数组，并返回新数组。 
reduce: 接受两个参数，第一个是回调，第二个是回调函数中的第一个参数，遍历数组，将每次返回的值作为下一次回调函数的第一个参数。
forEach: 无法通过传统的控制语句（break,return）来终止循环。可以通过在达到停止循环条件时使用throw new Error('终止循环')，再使用try{}catch(error){}来抓取错误。

# 十二、异步
- js 默认时单线程的

- 进程：多个程序同时执行的过程。
- 线程：一个程序的执行过程（一个任务的最小单元）。

对于浏览器来说，浏览器打开的每一个窗口都是一个进程，每个窗口的运行都由多个线程支持。
如何解决异步问题
1. 利用回调:函数过多时，前后互相嵌套，出现Bug会造成回调地狱，代码可读性差，维护困难
2. promise 
- then 方法的返回值是一个新的promise 状态为pending.then的pending状态会根据上一个promise状态修改而修改。

3. generator
    - generator函数得分执行返回一个Generator对象， 该对象包含一个next 方法
    - next 方法可以用来解除yeild 封印，不断地调用next 会让JS引擎不断地执行下一个yeild
    - 哪怕yeild A() 这个A有返回值，Generator函数依然不采用这个返回值，Generator函数只认自己下一个next传入的值

4. async await

- then 的原理
1. 接受两个参数，第一个是成功的回调，第二个是失败的回调
2. 返回一个新的 promise 
3. 当 then 执行到的时刻，then 前面的promise 状态已经变更为 fulfilled 或者rejected ，then中的回调函数由then自己执行
4. 当 then 执行到的时刻，then 前面的promise状态为pending,then中的回调函数会先被存放，等待promise的状态变更为fulfilled或者rejected 时再由resolve或者 reject执行。

# 十三、事件循环机制 Event Loop
- 线程之间可以同时工作，除了js线程和渲染线程，这两个线程不能同时进行。因为js可以修改dom,可能会出现渲染冲突。

- 同步代码：

- 异步代码：
- 宏任务队列：script,setTimeout,setInterval,I/O 操作,UI 渲染（具体取决于浏览器环境）

- 微任务队列：promise.then, mutationObserver, process.nextTick

V8执行步骤
1. 执行同步代码  （也叫宏任务）
2. 执行微任务队列中的任务
3. 有必要的话，会执行渲染
4. 执行宏任务队列中的任务
以上四步循环执行
- async/await
    - async 函数返回的是一个promise
    - await 后面接的代码作为同步代码立即执行
    - await 会间后续的代码挤入微任务中
    - await 后面接的promise状态无法变更为 fulfilled 或reject的话。会发生阻塞（死锁），代码的执行会一直停留在await上，出现这种情况时，await会主动让出主线程，让主线程去执行其他可行的任务。

# 十四、浏览器基础考点
- 事件机制(事件流：它描述了事件如何在页面的DOM结构中传播。理解事件流对于有效地处理用户交互和优化网页性能至关重要。事件流主要分为三个阶段：捕获阶段、目标阶段和冒泡阶段。)
    1. 事件从 window 上往目标处传播 ———— 捕获阶段 true
    2. 事件传播到目标处，会触发事件处理函数 ———— 
    3. 事件从目标处往 window 处传播  ———— 冒泡阶段 false(默认触发阶段)

- 事件委托 
：浏览器中的事件委托是一种利用事件冒泡机制，通过将事件监听器绑定到父元素上来处理子元素事件的技术，从而提高性能并简化动态内容管理。
简而言之，事件委托就是把事件处理器添加到父元素，用来处理发生在子元素上的事件，依靠事件冒泡实现。

- 跨域

- 浏览器的存储
  1. cookies () 最早被引入客户端的存储机制。后端控制有效时长4kb 存储字符串类型的键值对，可以设置跨域访问，会自动被携带在http的请求头中。
  2. LocalStorage (本地存储) 永久存储5-10M存储字符串类型的键值对，不能跨域访问。
  3. SessionStorage （会话存储）页面有效期内5-10M存储字符串类型的键值对，不能跨域访问。
  4. IndexedDB （客户端数据库）永久存储 无限大 可存储复杂的数据类型 不能跨域访问。

- 缓存
1. 强缓存
    - Expires 绝对时间
    - Cache-Control 相对时间
2. 协商缓存
    - Last-Modified 上次修改时间
    - If-Modified-Since 上次修改时间
    - ETag 资源唯一标识

- 渲染原理
    1. 解析html 得到dom树
    2. 解析css生成css规则树
    3. 将dom树和css规则树合并生成render树 （只包含可见的节点）
    4. 根据render树计算每个节点的位置 （回流）
    5. 将每个节点绘制到屏幕上 （重绘）GPU图形绘制能力
- 回流：页面上有元素的几何属性发生变化

- 重绘：页面上有元素的外观属性发生变化

- 浏览器的优化 
    浏览器维护了一个队列，当页面上出现需要回流的操作时，会将该操作放入队列中，当队列中需要处理的操作过多时，会一次性清空队列，只发生一次回流。这就是浏览器的优化。但是有很多属性会强制刷新队列，刷新队列不一定导致回流，要注意V8从上到下，从右到左的读取顺序。

- 在项目中有哪些减少回流重绘的方法
1. 使用 display:none/block 包裹内容，将需要大量回流的元素脱离文档流，回流完毕后再重新插入文档流。产生2次回流。
2.  使用文档碎片 createDocumentFragment() 将li放进frg中，在放会ul，只产生一次回流
3. 使用 cloneNode ,在使用ul.parentNode.replaceChild(cloneUl,ul) 进行 克隆体和本体的替换 

4. 不要一条一条的修改DOM样式。与其这样，不如定义好css 的class，然后修改DOM的className

# 十五、设计模式
    - 单例模式
    - 双例模式
    - *发布订阅模式 注意






