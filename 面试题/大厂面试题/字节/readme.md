# 基于这三点回答
- xxx是什么？
- xxx特性
- xxx的应用场景


1. 什么是跨域？（请你聊一下跨域问题）
- 同源策略
 1. 浏览器出于安全考虑（数据安全，服务器安全，减少XSS跨栈脚本攻击，CSRF请求伪造）
 2. http:// www.    abc.com :8000 / a.html
  协议    子域名   主域名   端口    路径

浏览器出于安全性考虑，所以设定了同源策略机制，主要是为了数据安全、服务器安全，同源策略中规定了两个http地址的协议，域名和端口号三者必须完全相同才会被认为是同源，否则为非同源，会出现跨域的问题

 3. 非同源，请求发送后，浏览器会拦截响应

- 跨域方案
1. jsonp （缺点：需要后端配合，只能发送get请求）
  1. 借助script标签的src属性不受同源策略限制，来发送请求
  2. 携带一个参数callback给到后端 
  3. 后端将数据作为callback函数的实参，返回给前端一个callback的调用形式
  4. 浏览器接受到callback的调用会自动执行全局的callback函数

2. CORS
    Access-Contontrol-Allow-Origin:设置'域名白名单'来通知浏览器哪些域名可以跨域访问

3. nginx反向代理
   1. 前端服务器和后端服务器不在同一域名下，前端服务器通过nginx反向代理来访问后端服务器
 

4.  node中间代理
   1. 前端服务器和后端服务器不在同一域名下，前端服务器通过node中间件来访问后端服务器

5. websocket
  1. 传统的前后端通信是基于HTTP协议的，是单向的，只能从一端发到另一端
  2. websocket 是基于tcp协议的，是双向的，可以双向发送(微信通话)
  3. socket协议一旦建立连接，皆可以保持通信状态，不需要每次都建立连接
  4. 天生就可以跨域

6. postMessage
    当父级页面和iframe页面不在统一域名下，他们之间的数据传输也存在跨域问题，父级页面和

7. document.domain
  同上（谷歌禁用了domain）


# 浏览器存储
1. localStorage（本地存储）
  永久存储  5-10M 存储字符串类型的键值对 不能跨域访问

2. sessionStorage （会话存储）
  页面有效期 5-10M 存储字符串类型的键值对 不能跨域访问

3. cookies（）
  后端控制有效时长 4kb 存储字符串类型的键值对  可以设置跨域访问（百度和百度贴吧）
  会自动被携带在http的请求头当中

4. indexedDB（客户端数据库） 
  永久存储   无限大  可存储复杂的数据类型   不能跨域访问

# JWT
  1. 是一种认证方式，用于在网络应用间安全传递信息
  2. 简洁，自包含性，安全性，跨语言跨平台
  3. 用于身份验证，授权和信息交换
  4. 生成JWT，使用，发送，验证


# 事件循环机制




# 归并排序
  - 分治
  1. 分治问题
  2. 求解每个子问题
  3. 合并子问题的解

# 浏览器缓存
  1. 后端响应给浏览器的内容是需要在响应头中设置 编码类型的
  2. HTTP 分为请求头和请求体 两部分 ，主要提供一种内容协商机制
  3. 静态资源的传输
  - HTTP缓存
    将页面上长时间不更新的资源缓存到浏览器上，下次访问也页面时该部分资源直接从缓存中获取，从而减少了网络请求的次数，提高了页面的加载速度

  1. 强缓存：
    在响应头中设置Cache-Control字段，该字段的值为max-age=xxx表示缓存的有效期，单位为秒

    通过浏览器url栏请求的资源，请求头中就会自动携带Cache-Control:max-age=0 字段，这种情况下请求到的资源无法被强缓存

    被缓存的资源在浏览器的cache Storage 中，本质上还是在硬盘上

    强制刷新浏览器，会清空浏览器的cache Storage 
      优点：加快网页加载速度，减少服务器负载和网络传输
      缺点：如果资源更新但仍在缓存有效期内，用户可能看到旧内容


  2. 协商缓存：
    强缓存对浏览器地址栏访问的无效，所以浏览器提供了协商缓存的机制

    - 浏览器第一次访问资源时，响应头中携带last-modified字段，值为该资源的最后修改时间，当浏览器接收到响应头后，会在该资源再次被请求时，在请求头中自动携带if-modified-since 字段，值为last-modified的值，后端检验请求头中的if-modified-since的值和last-modified的值是否一致，如果一致，就返回304状态码，浏览器就会从缓存中获取该资源，如果不一致，就返回200状态码，浏览器就会重新请求该资源

    last-modified+if-modified-since存在的问题：
    当文件被修改后但内容没有变更，last-modified的值会更新，从而导致资源重新被请求


    - etag（资源唯一标识符） + if-none-match

    只用强缓存可以把除URL地址栏访问的资源缓存起来，但是资源更新了就无法第一时间让前端获取到，所以还需要协商缓存

    只要命中了强缓存，就不会走协商缓存，只有强缓存到期，才会走协商缓存

    为了保证文件资源更新前端能够及时获取到，一般会在文件名后加上文件指纹，这样文件指纹就会改变（用内容生成hash值），从而保证文件资源的更新

      优点：确保用户获取最新资源，解决强缓存可能出现的缓存数据不一致问题
      缺点：每次请求都需与服务器交互，会增加一定的延迟和服务器负担


