# 弱类型，动态语言
1. 声明变量时不需要告诉v8该变量是什么类型，v8会自己计算出来 
2. 可以使用同一个变量保存不同类型的数据


# 垃圾回收
- 手动回收 c/c++

- 自动回收 JS Java Python


# 栈内存回收
- js引擎通过下移ESP指针来销毁该函数保存在栈中的执行上下文


# 堆内存回收
- 垃圾回收器

- 代际假说
1. 认为大部分对象在内存中存在的时间是很短的
2. 不死的对象，会活的非常久


# v8的堆
- 新生代区域：存放生存时间短的对象   1~8M  副垃圾回收器
- 老生代区域：生存时间长的对象       很大  主垃圾回收器


- 垃圾回收器工作流程：
1. 标记空间中活动对象和非活动对象
2. 回收掉非活动对象的内存
3. 内存整理 


# 新生代区域
1. 划分对象区域和空闲区域
2. 将对象区域中的活动对象复制到空闲区域，清空对象区域
3. 反转对象区域和空闲区域

- 两次之后还存活的对象就晋升到老生代区域

# 老生代区域
递归的标记每一个对象中存活的子区域，清理失活的对象，整理内存


# 全停顿
- 当垃圾回收算法生效的时候，js逻辑的执行就要停止，等待垃圾回收完成再执行

- 全停顿会造成页面卡顿

- 增量标记法

JavaScript中的垃圾数据回收机制是通过副垃圾回收器和主垃圾回收器来实现的。副垃圾回收器主要负责新生区的垃圾回收，采用Scavenge算法将新生代空间对半划分为对象区域和空闲区域，通过复制和角色翻转完成垃圾数据的回收。而主垃圾回收器则负责老生区的垃圾回收，采用标记-清除和标记-整理算法来处理大对象和长生命周期对象的回收。在执行垃圾回收时，由于JavaScript运行在主线程上，会导致全停顿现象，影响应用的性能和响应能力。为了降低全停顿的影响，V8引擎采用增量标记算法来分解垃圾回收任务，使其与JavaScript应用逻辑交替执行，从而减少页面卡顿现象
