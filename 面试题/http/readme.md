# UDP 协议

1. 面向无连接（知道了对面的 IP 地址后就直接传输数据）
2. 只做数据报文的搬运工（不增加额外的报文头部）
3. 不保证数据包的有序性
4. 不保证数据的可靠性（丢包）
5. 没有拥塞控制
6. 高效

- 一对一 单播
- 一对多 多播
- 多对多 广播

- 直播，视频，实时性要求高的应用

# TCP 协议

1. 头部信息多

- Sequence Number (序列号)
- Acknowledgment Number(确认号)
- Window Size 窗口大小(网络环境支持传输多少字节的数据)
- 标识符
  URG = 1 紧急报文
  ACK = 1 确认报文
  PSH = 1 接收端应该立即将数据传给应用层
  RST = 1 复位连接 == 需要重连
  SYN = 1 建立连接
  FIN = 1 关闭连接

  - 三次握手
    1. 客户端发送 SYN 报文，请求建立连接（客户端进入 SYN-SEND 状态）
    2. 服务端收到 SYN 报文，回复 SYN+ACK 报文（服务端进入 SYN+RECEIVED 状态）
    3. 客户端收到 SYN+ACK 报文，恢复 ACK 报文（客户端和服务端同时进入 ESTABLISHED 状态）

### 为什么要三次握手？两次握手行不行

假设客户端向服务端发送一个连接请求 A，但是网络环境差，导致 A 报文丢失，TCP 的超时重传会让客户端重新再发一个连接请求 B，此时服务端顺利接收到 B 报文，然后服务端回复一个确认报文，如果此时连接就建立成功的话，客户端和服务端就开始通信，通信结束后断开连接。但 A 报文有可能再次回复一个确认报文，并进入 ESTABLISHED 状态，而此时客户端已经下线，服务端会一直等待客户端的数据通讯，造成资源浪费。

- HTTP 协议 数据传输

- 四次挥手
  1. 客户端向服务端发送 FIN 报文，请求断开连接（客户端进入 FIN-WAIT-1 状态）
  2. 服务端收到 FIN 报文，回复 ACK 报文 （服务端进入 CLOSE-WAIT 状态）
  3. 服务端将未传输完的数据传输完后，向客户端发送 FIN 报文，请求断开连接 （服务端进入 LAST_ACK 状态）
  4. 客户端收到 FIN 报文，回复 ACK 报文（客户端进入 TIME-WAIT 状态，一段时间后 CLOSED）此时服务端进入 CLOSED 状态

# HTTP 0.9

- 传输体积很小的 html 超文本

- 特点
  1. 只有请求行，没有请求头，没有请求体
  2. 服务端没有返回头信息
  3. 返回的内容以 ASCII 的字符流传输

# HTTP 1.0

- 万维网联盟 （W3C）和 HTTP 工作组成立
- 浏览器展示的不仅是 HTML ，还有 js,css,图片，音频，视频等
- HTTP 需要支持不仅限于 ASCII 的编码，还需要支持多种编码

- 特点

1.  增加请求头，响应头 key-value

- 1.0 需要解决的问题

1. 浏览器需要知道服务器返回的内容是什么类型
2. 浏览器需要知道服务器用了什么压缩方式
3. 浏览器要能告诉服务器自己需要的语言类型
4. 浏览器需要知道文件编码类型

- 请求头

1. accept:text/html(浏览器能接受的压缩方式)
2. accept-encoding:gzip,deflate,br (浏览器能接受的压缩方式)
3. accept-language：zh-CN,zh;q=0.9(浏览器能接受的语言类型)
4. accept-charest:UTF-8,ISO-8859-1;q=0.7(浏览器能接受的编码类型)

- 响应头

1.  content-type：text/html; charset=utf-8(服务器返回的类型)
2.  content-encoding:gzip(服务器用的压缩方式)
3.  content-language:zh-CN(服务器用的语言类型)

- 状态码

1. 2xx

   - 200 成功
   - 204 成功，但是没有内容
   - 205 成功，报文不含有实体
   - 206 成功，报文只含有实体的一部分

2. 3xx 重定向

   - 301 永久重定向
   - 302 临时重定向
   - 303 临时重定向，使用 GET 请求
   - 304 协商缓存

3. 4xx

   - 400 客户端请求错误（报文存在语法错误）
   - 401 未授权
   - 403 禁止访问
   - 404 未找到

4. 5xx
   - 500 服务器内部错误
   - 501 服务器不支持当前请求所需要的某个功能
   - 502 作为网关或代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
   - 503 服务器暂时处于超负载或正在进行停机维护，无法处理请求

- Cache 机制
- 用户代理

# HTTP 1.1

- 1.0 的缺陷

  1. 每一次请求都要重新建立连接

- 1.1 的特点

  1. 增加了持久连接（一个 TCP 连接有多个 HTTP 连接）
  2. 允许同时建立 6 个 TCP 持久连接
  3. 增加了带宽优化机制
  4. 增加 host 字段
  5. 客户端增加了 cookie

- 队头阻塞
  1. 一个 TCP 连接中，前面的请求没有返回，后面的请求就会阻塞

# HTTP 2.0

- 1.1 的缺陷

  1.  队头阻塞
  2.  带宽利用率低

  - TCP 慢启动
  - 同时建立 6 个 TCP 连接，导致每个连接之间竞争带宽
  - HTTP 队头阻塞
    如果第一个请求响应延迟，后续的请求会被阻塞，即使他们已经准备就绪。

- 2.0 多路复用

  1. 一个域名下，只需建立一个 TCP 连接
  2. 二进制分帧层，将请求全部打包成帧，帧与帧之间互不干扰，并打上编号，服务端可以根据编号的优先级来处理加急的请求

- TCP 队头阻塞
  若 TCP 数据包丢失（如网络抖动），后续包会被阻塞，直到丢失包重传成功。

影响同一连接上的所有 HTTP/2 流，导致整体性能下降。

# HTTPS 和 HTTP 区别

- HTTPS 是 HTTP 的安全版本（HTTP+SSL/TLS）
- TLS 加密：
  1. 对称加密：
     两边拥有相同的密钥，两边都知道如何解密
  2. 非对称加密（为了让两边拥有相同的钥匙）：
  - 客户端生成密钥
  - 服务端生成公钥 + 私钥
  - 服务端将公钥发送给客户端
  - 客户端用公钥加密密钥并传输给服务端

# HTTP 3.0

- 2.0 的缺陷

  1. TCP 的队头阻塞（超时重传）
  2. TCP 慢启动（拥塞控制）
  3. TCP 连接的建立和关闭（耗时）

- TCP 协议僵化

- QUIC 协议

  1. 基于 UDP 协议
  2. 多路复用
  3. 有序性
  4. 快速握手
  5. 可靠性 流量控制

- 设备更换版本导致 3.0 没有普及
